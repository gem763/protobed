{% extends "florence/layout.html" %}

{% block css %}
  {{ block.super }}
  <style>
  </style>
{% endblock css %}


{% block mastbody %}
<div class="ui center aligned vertical segment" style="background:none;border:none;">
  <div id='module'>
    <importview :imported='imported'></importview>
    <editorview :code='code' @testify='testify'></editorview>

    <div id='chart' class='ui text container' style='background:none;padding:0;height:300px;'>
      <!-- <svg style='background:lightyellow;width:100%;height:100%;'></svg> -->
    </div>
  </div>
</div>
{% endblock mastbody %}


{% block js %}
  {{ block.super }}
  {% include "florence/vcomp/importview.html" %}
  {% include "florence/vcomp/libview.html" %}
  {% include "florence/vcomp/editorview.html" %}

  <script>
    var module = new Vue({
      el: '#module',
      delimiters: ['[[', ']]'],
      data: {
        imported: {},
        code: `const stock = new alpha.Alphastock();
// stock.test();


class LineViewer extends gen.BaseViewer {
  opt = {
    margin: {top: 30, right: 30, bottom: 50, left: 50},
    linecolor: 'orange',
    linewidth: '3px',
    x_field: 'date',
    y_field: 'close',
  };

  show(where) {
    const opt = this.opt;
    const svg = d3.select(where)
                  .html('')
                  .append("svg")
                  .attr('width', '100%')
                  .attr('height', '100%')
                //   .style('background', 'lightyellow')
                  .append("g")
                  .attr("transform", "translate(" + opt.margin.left + "," + opt.margin.top + ")");

    const canvas = d3.select('#chart').node().getBoundingClientRect();
    const width = canvas.width - opt.margin.left - opt.margin.right;
    const height = canvas.height - opt.margin.top - opt.margin.bottom;

    const parseTime = d3.timeParse("%Y-%m-%d");
    const x = d3.scaleTime().range([0, width]);
    const y0 = d3.scaleLinear().range([height, 0]);

    const line0 = d3.line()
                    .x(d => x(d[opt.x_field]))
                    .y(d => y0(d[opt.y_field]));


    this.sourcer.get(this.sourcer.opt).then(data => {
      // format the data
      data.forEach(d => {
        d.date = parseTime(d[opt.x_field]);
        d.close = +d[opt.y_field];
      });

      const y_min = d3.min(data, d => Math.min(d[opt.y_field])) * 0.97;
      const y_max = d3.max(data, d => Math.max(d[opt.y_field])) * 1.03;

      // Scale the range of the data
      x.domain(d3.extent(data, d => d[opt.x_field]));
      y0.domain([y_min, y_max]);

      // Add the line0 path.
      svg.append("path")
         .data([data])
         .style('fill', 'none')
         .style('stroke', opt.linecolor)
         .style('stroke-width', opt.linewidth)
         .attr("d", line0);

      // Add the X Axis
      svg.append("g")
         .attr("transform", "translate(0," + height + ")")
         .call(d3.axisBottom(x));

      // Add the Y0 Axis
      svg.append("g")
         .call(d3.axisLeft(y0));
    });
  }
}

const linechart = new LineChart(stock);
linechart.show('#chart');`
      },

      methods: {
        testify: function(code) {
          testify(code);
        }
      }
    });


    function testify(code) {
      var testmodule = modulize({
        imports:module.imported,
        code:code
      });

      testmodule = `
        requirejs.config(${JSON.stringify(requirejs_config)});
        requirejs([${JSON.stringify(testmodule)}], function() {});
      `

      let blob = new Blob([testmodule], {type: 'text/javascript'});
      let js = URL.createObjectURL(blob);

      console.log(js);
      import(js).then(testjs => {});
    }


    const requirejs_config = {
      paths: {},
      shim: {}
    };

    function modulize(tree) {
      let modulized;
      let exps;

      if (tree.exports) {
        exps = tree.exports.map(exp => exp + ':' + exp).join(', ');
      }

      if ($.isEmptyObject(tree.imports)) {
        modulized = `define(function(){
          ${tree.code}
          return { ${exps} }
        })`;

      } else {
        let _imports = math.transpose(Object.entries(tree.imports));
        var path;
        var id;

        let _modulized = _imports[1].map(function(imp) {
          if (imp.url) {
            path = imp.url.replace(/.js$/, '');
            id = path.replace(/^https?:\/\//, '');
            requirejs_config.paths[id] = path;

            // 이 부분을 좀더 분화할 필요가 있다 2020.03.09
            if (imp.name=='jquery')
              requirejs_config.shim[id] = { exports: '$' };

            else if (imp.name=='underscore.js')
              requirejs_config.shim[id] = { exports: '_' };

            return id;

          } else {
            return modulize(imp);
          }
        });

        modulized = `define(${JSON.stringify(_modulized)}, function(${_imports[0]}) {
          ${tree.code}
          return { ${exps} }
        })`
      }

      let blob = new Blob([modulized], {type: 'text/javascript'});
      return URL.createObjectURL(blob);
    }
  </script>
{% endblock js %}
